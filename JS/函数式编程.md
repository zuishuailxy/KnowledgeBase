# 函数式编程

## 定义

函数式编程是一种 编程范式，和面向对象（OOP）并列。它强调：

- 函数是一等公民（函数可以作为参数传递、作为返回值、存储在变量中）
- 数据不可变（避免直接修改原数据，返回新数据）。
- 无副作用（函数只依赖输入参数，输出固定，不依赖外部状态）。
- 声明式（描述“做什么”，而不是“怎么做”）。

## 基础概念

### 1. 纯函数

1. 相同输入 → 必定相同输出。
2. 不修改外部变量（无副作用）。

```js
// 纯函数
const add = (a, b) => a + b;

// 非纯函数（依赖外部变量）
let x = 10;
function addX(y) {
  return x + y;
}
```

### 2.不可变数据

- 不要改变原数据而是返回新的数据

```js
// 不可变操作
const arr = [1, 2, 3];
const newArr = [...arr, 4]; // [1,2,3,4]

// 可变操作（不推荐）
arr.push(4);
```

### 3. 高阶函数

- 函数可以接收函数作为参数，或者返回一个函数。

```js
// map 是典型的高阶函数
[1, 2, 3].map((x) => x * 2); // [2, 4, 6]

// 返回函数
const multiplier = (x) => (y) => x * y;
const double = multiplier(2);
console.log(double(5)); // 10
```

### 4. 柯林化

- 把一个多参数函数，转换成一系列 接收单一参数 的函数。

```js
function add(a, b) {
  return a + b;
}

// 柯里化
function curryAdd(a) {
  return function (b) {
    return a + b;
  };
}

curryAdd(2)(3); // 5
```

### 5. 函数组合

- 把多个小函数组合成一个大函数（像管道）。

```js
// 创建pipe / compose
const compose =
  (...fns) =>
  (value) =>
    fns.reduceRight((acc, fn) => fn(acc), value);

const pipe =
  (...fns) =>
  (value) =>
    fns.reduce((acc, fn) => fn(acc), value);

const toUpper = (str) => str.toUpperCase();
const exclaim = (str) => str + "!";
const greet = (str) => `Hi, ${str}`;

const welcome = compose(exclaim, toUpper, greet);
console.log(welcome("magicYoung"));
// Hi, MAGICYOUNG!
```

### 实际应用

1. 数据处理管道

```js
// 数据处理管道
const processUsers = (users) => {
  return users
    .filter((user) => user.age >= 18) // 成年人
    .filter((user) => user.active) // 活跃用户
    .map((user) => ({
      ...user,
      displayName: `${user.name} (${user.age}岁)`,
      category: user.age < 30 ? "青年" : "中年",
    }))
    .sort((a, b) => a.age - b.age);
};
```

2. 使用函数组合构建验证器

```js
const isString = (value) => typeof value === "string";
const isNotEmpty = (value) => value.trim().length > 0;
const hasMinLength = (min) => (value) => value.length >= min;
const hasMaxLength = (max) => (value) => value.length <= max;

const createValidator =
  (...validators) =>
  (value) =>
    validators.every((validator) => validator(value));

const usernameValidator = createValidator(
  isString,
  isNotEmpty,
  hasMinLength(3),
  hasMaxLength(20)
);
```

3. 记忆化

```js
function memoize(fn) {
  const cache = new Map();
  return function (...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}

// 昂贵的斐波那契计算
const fibonacci = memoize(function (n) {
  if (n < 2) return n;
  return fibonacci(n - 1) + fibonacci(n - 2);
});
```

4. 实用工具

```js
// 防抖
const debounce = (fn, delay) => {
  let timeoutId;
  return function (...args) {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn.apply(this, args), delay);
  };
};

// 节流
const throttle = (fn, interval) => {
  let lastCall = 0;
  return function (...args) {
    const now = Date.now();
    if (now - lastCall >= interval) {
      lastCall = now;
      return fn.apply(this, args);
    }
  };
};

// 深度克隆（函数式方法）
const deepClone = (obj) => {
  if (obj === null || typeof obj !== "object") return obj;
  if (obj instanceof Date) return new Date(obj.getTime());
  if (obj instanceof Array) return obj.map(deepClone);
  if (typeof obj === "object") {
    return Object.keys(obj).reduce((cloned, key) => {
      cloned[key] = deepClone(obj[key]);
      return cloned;
    }, {});
  }
};
```

### 函数式编程 vs 面向对象编程

| 对比点   | 函数式编程 (FP)    | 面向对象 (OOP) |
| -------- | ------------------ | -------------- |
| 核心思想 | 函数组合           | 类与对象       |
| 数据处理 | 不可变，返回新对象 | 修改对象属性   |
| 状态管理 | 无状态/不可变      | 内部封装状态   |
| 复用方式 | 高阶函数/组合      | 继承/多态      |

### 总结

1. 纯函数优先

- 无副作用：不修改外部状态
- 引用透明：相同输入总是相同输出
- 可预测性：便于测试和推理

2. 数据不可变

- 使用 ...spread 创建新对象/数组
- 避免直接修改原始数据
- 函数返回新值而非修改旧值

3. 函数组合

- 将复杂问题分解为小函数
- 通过组合构建复杂逻辑
- pipe 和 compose 是核心工具
