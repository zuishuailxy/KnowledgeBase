# 构建工具与模块化

## 模块化

模块化就是把代码拆成独立、可复用、低耦合的模块，并通过“导入 / 导出”的方式来拼装。

## 常见的 JS 模块化规范

1. commonjs

```js
// 导出
module.exports = {
  add: function (a, b) {
    return a + b;
  },
};

// 导入
const math = require("./math");
```

2. ES6 Modules (ESM)

```js
// 导出
export function add(a, b) {
  return a + b;
}

export default class Calculator {
  // ...
}

// 导入
import { add } from "./math.js";
import Calculator from "./calculator.js";
```

3. AMD(异步模块定义)

```js
// 定义模块
define(["jquery"], function ($) {
  return {
    init: function () {
      // 初始化代码
    },
  };
});

// 使用模块
require(["myModule"], function (myModule) {
  myModule.init();
});
```

## CSS 模块化

传统 CSS 的问题：

- 全局作用域：一个 .btn 可能在不同组件冲突。
- 维护困难：随着项目变大，class 命名混乱。
- 复用差：难以做到组件级复用。

CSS 模块化就是解决这类问题的：让样式作用域局限在组件内，避免全局污染。

### 常见的 css 模块化方案

#### 1.CSS Module

- 原生支持于 webpack / Vite
- 使用时样式会被编译成 哈希唯一类名
- 在 JS / TS 里直接引用

```css
/* Button.module.css */
.btn {
  background: blue;
  color: white;
}
```

```jsx
// React / Vue SFC 中
import styles from "./Button.module.css";

export default function Button() {
  return <button className={styles.btn}>Click</button>;
}
```

#### 2. 预处理器 + BEM 命名

- 使用 Sass/Less + BEM（Block Element Modifier）命名规范
- 通过命名空间避免冲突

```scss
// button.scss
.button {
  &__text {
    color: white;
  }
  &--primary {
    background: blue;
  }
}
```

```html
<button class="button button--primary">
  <span class="button__text">Click</span>
</button>
```

#### 3. Scoped CSS（Vue 特有）

Vue 单文件组件支持 scoped，编译时自动加上 data-xxx 属性选择器：

```vue
<template>
  <button class="btn">Click</button>
</template>

<style scoped>
.btn {
  color: red;
}
</style>
```

#### 4. css-in-js

- 直接用 JS 写 CSS，样式和逻辑在一起
- 常见库：styled-components、Emotion（React 生态）

```jsx
import styled from "styled-components";

const Button = styled.button`
  background: blue;
  color: white;
`;
```

#### 5. 工具类框架

```html
<button class="bg-blue-500 text-white px-4 py-2 rounded">Click</button>
```
