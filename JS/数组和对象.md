# 数组

### 定义

一个有序的数据集合，从数字索引0开始

### 特点

| 特点             | 说明                       |
| ---------------- | -------------------------- |
| 有序集合         | 元素按插入顺序排列         |
| 数字索引         | 通过数字（下标）访问元素   |
| 动态长度         | 可随时添加/删除元素        |
| 可以存放任意类型 | 可混合字符串、对象、函数等 |

### 常用方法

#### 增删改查

```js
arr.push(4);     // 将指定的元素添加到数组的末尾，并返回新的数组长度
arr.pop();       // 删除最后一个元素，并返回该元素的值。此方法会更改数组的长度。
arr.unshift(0);  // 指定元素添加到数组的开头，并返回数组的新长度。
arr.shift();     // 从数组中删除第一个元素，并返回该元素的值。此方法更改数组的长度。
arr.splice(1, 1); // 就地移除或者替换已存在的元素和/或添加新的元素。删除第 1 个
arr.splice(2, 0 , 'a', 'n')  // 在索引 2 处移除 0 个元素，并插入“a”和“n”
```

#### 遍历

```js
arr.forEach(item => console.log(item));
const newArr = arr.map(x => x * 2);
const filtered = arr.filter(x => x > 2);
```

#### 查找

```js
arr.includes(3);
arr.indexOf(2); // 找不到返回 -1
arr.some()
arr.find()
arr.filter()
```

# 对象

### 定义

对象是由键值对（key-value）组成的无序集合。

### 特点

| 特点                    | 说明                     |
| ----------------------- | ------------------------ |
| 无序结构                | 属性没有固定顺序         |
| 键必须是字符串或 Symbol | 数字会自动转为字符串     |
| 可嵌套                  | 可以存对象、数组、函数等 |

### 属性访问

```js
obj.name       // 点访问
obj['name']    // 方括号访问（可动态）
```

### 增删改查

```js
obj.city = "Beijing";     // 添加/修改
delete obj.age;           // 删除属性
'name' in obj             // 检查属性
Object.keys(obj);         // 获取所有 key
```

### 遍历

```js
for (let key in obj) {
  console.log(key, obj[key]);
}
Object.entries(obj).forEach(([k, v]) => {
  console.log(k, v);
});
```

## Map/Set 与对象/数组的区别

### 核心概念

|          | `Object`                           | `Map`                        |
| -------- | ---------------------------------- | ---------------------------- |
| 键类型   | 字符串或 Symbol                    | 任何类型（对象、函数、数字） |
| 顺序     | 插入顺序未保证（新版本中开始保序） | 严格保持插入顺序             |
| 性能     | 大量增删查操作时性能较差           | 优化过，查找/插入性能更好    |
| 迭代     | `for...in`、`Object.keys()`        | `map.forEach()`、`for...of`  |
| 常用用途 | 存储结构化数据                     | 高性能键值对、频繁增删查结构 |

|              | `Array`                    | `Set`                          |
| ------------ | -------------------------- | ------------------------------ |
| 是否允许重复 | ✅ 是                       | ❌ 不允许（自动去重）           |
| 查找性能     | ❌ 慢（`indexOf`是 O(n)）   | ✅ 快（近似 O(1)）              |
| 用途         | 有序数据列表               | 唯一值集合                     |
| 遍历方式     | `forEach`、`map`、`filter` | `forEach`、`for...of`、`has()` |

### 浅拷贝 和 深拷贝

#### 浅拷贝

**​定义**：只复制对象的第一层属性，对于嵌套的对象或数组，复制的是​**引用地址**​。

```js
const original = {
  name: '张三',
  age: 25,
  hobbies: ['读书', '游泳'],
  address: {
    city: '北京',
    district: '朝阳区'
  }
};

// 1. Object.assign()
const copy1 = Object.assign({}, original);

// 2. 展开运算符 (...)
const copy2 = { ...original };

// 3. Array.from() (仅数组)
const arr = [1, 2, [3, 4]];
const copyArr1 = Array.from(arr);

// 4. slice() (仅数组)
const copyArr2 = arr.slice();

console.log('原始对象:', original);
console.log('浅拷贝:', copy1);

// 修改第一层属性
copy1.name = '李四';
console.log('修改name后:');
console.log('原始:', original.name); // '张三' - 不受影响
console.log('拷贝:', copy1.name);    // '李四'

// 修改嵌套对象
copy1.address.city = '上海';
console.log('修改嵌套对象后:');
console.log('原始:', original.address.city); // '上海' - 受影响！
console.log('拷贝:', copy1.address.city);    // '上海'
```

#### 深拷贝

​**定义**​：递归复制对象的所有层级，创建完全独立的新对象。

**深拷贝的方法**

1. JSON 方法

```js
const original = {
  name: '张三',
  age: 25,
  hobbies: ['读书', '游泳'],
  address: {
    city: '北京',
    district: '朝阳区'
  }
};

// JSON 深拷贝
const deepCopy = JSON.parse(JSON.stringify(original));

// 修改嵌套对象
deepCopy.address.city = '上海';
console.log('原始:', original.address.city); // '北京' - 不受影响
console.log('拷贝:', deepCopy.address.city);  // '上海'

// JSON 方法的限制：
const complexObj = {
  fn: function() { return 'function'; },    // 函数会丢失
  date: new Date(),                         // 日期变成字符串
  regex: /test/g,                          // 正则变成空对象
  undefined: undefined,                     // undefined 会丢失
  symbol: Symbol('test'),                  // Symbol 会丢失
  circular: null                           // 循环引用会报错
};

const copy = JSON.parse(JSON.stringify(complexObj));
console.log(copy);
// 结果: { date: "2023-...", regex: {} }
```

2. 手写递归

```js
function deepClone(obj, visited = new WeakMap()) {
  // 处理 null 和非对象类型
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理循环引用
  if (visited.has(obj)) {
    return visited.get(obj);
  }
  
  // 处理日期对象
  if (obj instanceof Date) {
    return new Date(obj.getTime());
  }
  
  // 处理正则对象
  if (obj instanceof RegExp) {
    return new RegExp(obj.source, obj.flags);
  }
  
  // 处理数组
  if (Array.isArray(obj)) {
    const clonedArray = [];
    visited.set(obj, clonedArray);
    for (let i = 0; i < obj.length; i++) {
      clonedArray[i] = deepClone(obj[i], visited);
    }
    return clonedArray;
  }
  
  // 处理普通对象
  const clonedObj = {};
  visited.set(obj, clonedObj);
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      clonedObj[key] = deepClone(obj[key], visited);
    }
  }
  
  return clonedObj;
}

// 测试
const original = {
  name: '张三',
  date: new Date(),
  regex: /test/g,
  fn: function() { return 'hello'; },
  nested: {
    count: 1,
    items: [1, 2, { deep: 'value' }]
  }
};

const cloned = deepClone(original);
cloned.nested.count = 999;
console.log('原始:', original.nested.count); // 1
console.log('克隆:', cloned.nested.count);   // 999
```

3. 使用structuredClone (现代浏览器)

```js
// 浏览器原生方法 (Chrome 98+, Firefox 94+)
const original = {
  name: '张三',
  date: new Date(),
  nested: { count: 1 }
};

const cloned = structuredClone(original);
```

对比

| 特性     | 浅拷贝             | 深拷贝                 |
| -------- | ------------------ | ---------------------- |
| 复制层级 | 仅第一层           | 所有层级               |
| 嵌套对象 | 共享引用           | 独立复制               |
| 性能     | 快                 | 慢                     |
| 内存占用 | 少                 | 多                     |
| 适用场景 | 简单对象、性能敏感 | 复杂嵌套、需要完全独立 |
