# 事件循环

因为JS 是单线程的，所以需要事件循环来调度同步任务和异步任务。

## 调用栈 call stack

- js 代码从主线程开始执行
- 同步代码会依次进入调用栈并执行
- 异步任务 （定时器， Promise， 事件监听）不会直接执行，而是交给宿主环境（浏览器 / Node.js） 处理。

## 任务队列 Task queue

任务分为：

- 宏任务（macrotask）：
  每次事件循环会执行一个宏任务。
  包含： setTimeout, setInterval, setImmediate（Node.js）, requestAnimationFrame, I/O, 事件回调, script整体代码

- 微任务 （mircotask）：
  在当前宏任务结束后，立即执行队列里的所有微任务。
  包含：Promise.then, process.nextTick（Node.js）, MutationObserver， queueMicrotask

## 事件循环流程 同步代码 → 微任务 → 宏任务

1. 执行全局代码 （第一个宏任务）
2. 遇到异步任务 -> 交给宿主环境处理
3. 执行完同步代码后 → 检查微任务队列，一次性清空。
4. 若微任务清空完成 → 再从宏任务队列取出下一个任务，放到执行栈中。
5. 重复以上步骤 → 形成 循环（event loop）。

## 示例

```js
console.log("start");

setTimeout(() => {
  console.log("timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("promise");
});

console.log("end");

```

👉 执行顺序：

1. console.log("start") → 同步任务

2. setTimeout(...) → 加入 宏任务队列

3. Promise.then(...) → 加入 微任务队列

4. console.log("end") → 同步任务

5. 清空 微任务队列 → 输出 "promise"

6. 取出宏任务（setTimeout） → 输出 "timeout"

## 总结口诀

- 先执行栈 → 微任务 → 宏任务

- 微任务永远比宏任务先执行
