# 事件循环

因为JS 是单线程的，所以需要事件循环来调度同步任务和异步任务。

## 调用栈 call stack

- js 代码从主线程开始执行
- 同步代码会依次进入调用栈并执行
- 异步任务 （定时器， Promise， 事件监听）不会直接执行，而是交给宿主环境（浏览器 / Node.js） 处理。

## 任务队列 Task queue

任务分为：

- 宏任务（macrotask）：
  每次事件循环会执行一个宏任务。
  包含： setTimeout, setInterval, setImmediate（Node.js）, requestAnimationFrame, I/O, 事件回调, script整体代码

- 微任务 （mircotask）：
  在当前宏任务结束后，立即执行队列里的所有微任务。
  包含：Promise.then, process.nextTick（Node.js）, MutationObserver， queueMicrotask

## 事件循环流程 同步代码 → 微任务 → 宏任务

1. 执行全局代码 （第一个宏任务）
2. 遇到异步任务 -> 交给宿主环境处理
3. 执行完同步代码后 → 检查微任务队列，一次性清空。
4. 若微任务清空完成 → 再从宏任务队列取出下一个任务，放到执行栈中。
5. 重复以上步骤 → 形成 循环（event loop）。

## 示例

```js
console.log("start");

setTimeout(() => {
  console.log("timeout");
}, 0);

Promise.resolve().then(() => {
  console.log("promise");
});

console.log("end");

```

👉 执行顺序：

1. console.log("start") → 同步任务

2. setTimeout(...) → 加入 宏任务队列

3. Promise.then(...) → 加入 微任务队列

4. console.log("end") → 同步任务

5. 清空 微任务队列 → 输出 "promise"

6. 取出宏任务（setTimeout） → 输出 "timeout"

## 总结口诀

- 先执行栈 → 微任务 → 宏任务

- 微任务永远比宏任务先执行

## setTimeout 、 setInterval

### setTimeout(fn, delay)

在指定的延时时间后，将fn回调推入 宏任务队列 执行，不保证精准时间

setTimeout(fn, 0) ≠ 立即执行，它只是「尽快在宏任务队列执行」，仍要等同步代码 + 微任务执行完。

### setInterval

每隔 delay 毫秒，将fn回调推入宏任务队列（重复执行，直到 clearInterval 停止）。

### 共同点

- 是 宏任务（MacroTask）。
- 都由 宿主环境（浏览器 / Node.js） 提供，JS 引擎本身没有定时器。
- 都不会阻塞主线程，真正执行取决于 事件循环，所以并不保证「准时」。

### 常见坑点

1. 最小延时至少 4ms
2. setInterval 可能堆积：
    如果回调执行时间 > 间隔，任务会排队，造成 任务堆积。
    更推荐用 递归 setTimeout 模拟 setInterval，保证间隔可控：

    ```js

    function myInterval(fn, delay) {
      function loop() {
        setTimeout(() => {
          fn();
          loop();
        }, delay);
      }
      loop();
    }

    myInterval(() => console.log("tick"), 1000);
    ```

3. 丢帧问题

- 用 setInterval(fn, 16) 试图实现动画时，可能掉帧，因为 JS 回调和渲染不在同一节奏。

- 更好的做法是用 requestAnimationFrame 来做动画。

## 总结

setTimeout(fn, 0) → 不等于立即执行，实际是「同步代码 + 微任务执行完后，才进队列」。

setInterval 不靠谱（可能堆积），递归 setTimeout 更精准。

做动画优先 requestAnimationFrame，做延时任务才用定时器。

### requestAnimationFrame

简称 rAF 是前端性能优化里非常关键的 API，主要用于动画渲染。

1. 基本概念

   - 告诉浏览器在下次重绘之前，执行回调
   - 回调函数的执行频率≈浏览器刷新率，大多数屏幕是 60Hz → 每 16.6ms 执行一次）。不会「丢帧」或「多余绘制」

2. 用法

    ```js
    function animate() {
      // 在这里更新元素位置、透明度、缩放等
      box.style.left = (parseInt(box.style.left) || 0) + 2 + "px";

      // 递归调用
      requestAnimationFrame(animate);
    }

    // 启动动画
    requestAnimationFrame(animate);
    ```

3. 取消动画

    和定时器类似，requestAnimationFrame 也有 ID，可以用 cancelAnimationFrame 停止。

    ```js
    let id;

    function move() {
      box.style.left = (parseInt(box.style.left) || 0) + 2 + "px";
      id = requestAnimationFrame(move);
    }

    id = requestAnimationFrame(move);

    // 停止动画
    setTimeout(() => {
      cancelAnimationFrame(id);
    }, 2000);
    ```
