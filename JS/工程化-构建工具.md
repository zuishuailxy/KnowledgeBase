# 构建工具

## 什么是前端构建工具

构建工具是将开发环境的源代码转换为生产环境可执行代码的自动化工具链。主要解决：

- 代码转译：ES6+/TS → ES5，SCSS/LESS → CSS
- 模块打包：将多个文件合并，处理依赖关系
- 资源优化: 压缩, Tree Shaking, Code Splitting
- 开发效率: 热更新, Source Map, 错误提示

## 常见构建工具

### Vite

#### 设计哲学

- 开发阶段： 不预先整体打包，直接把源码以原生 ESM 提供给浏览器 + 对第三方依赖做 预打包（pre-bundling），并借助 esbuild 做超快的转换（例如把 CommonJS 转成 ESM、TS 快速转译），从而实现极短的冷启动与精准 HMR。
- 生产阶段： 用 Rollup 做完整打包（code-splitting、静态资源哈希、tree-shaking 等），生成对外发布的产物。

#### 核心机制

1. ESModule 原生支持

    ```js
    <!-- 开发环境 - 浏览器直接加载 -->
    <script type="module" src="/src/main.js"></script>

    <!-- main.js -->
    import { createApp } from 'vue' // 会被转换为 /__vite__/deps/vue.js
    import App from './App.vue'     // 直接加载源文件
    ```

2. 依赖预构建

    ```js
    // vite.config.js - 依赖预构建配置
    export default {
      optimizeDeps: {
        // 强制预构建
        include: ['lodash-es', 'axios'],
        // 排除预构建
        exclude: ['some-local-lib'],
        // 自定义 esbuild 选项
        esbuildOptions: {
          target: 'es2020'
        }
      }
    }
    ```

    预构建的作用：

    - 将 CommonJS 转换为 ESM
    - 合并有大量内部模块的包（如 lodash-es 有 600+ 模块）
    - 缓存在 node_modules/.vite/ 目录

3. 热更新（HMR）

- 修改 → 仅编译单个文件 → HMR (< 200ms)

#### 开发（dev server）与生产（build）的流水线详解

1. 预打包（依赖优化）：启动时 Vite 会扫描项目的依赖（bare imports），把 node_modules 中那些“笨重/多模块”的依赖用 esbuild 预打包成单个 ESM 文件，写入缓存（node_modules/.vite/deps），减少浏览器请求次数并解决 CJS→ESM 兼容问题。这个步骤是 cold-start 快的重要原因。
2. 按需转换（on-demand transform）：当浏览器请求某个源码模块时，Vite 按需使用 esbuild（或插件链）把源码转换后返回——不是先把整个应用打包好再提供。这样启动常数时间（即使项目大）。同时 HMR 基于 ESM 的模块边界做到更细粒度更新
3. 生产构建：vite build 会走 Rollup 的打包流程（用 Vite 的预设和插件），做最终的 tree-shaking、code-splitting、资源哈希、压缩等。

#### TypeScript、转译与类型检查

Vite 用 esbuild 做快速“转译”（transpile-only） —— 会把 .ts/.tsx/.vue 中的 TS 语法去掉类型并产出 JS，但并不做完整的类型检查（因为 type-check 需要全图分析，会拖慢 dev 速度）。因此在团队里通常把类型检查放到 CI（tsc --noEmit）或使用专门插件在开发时跑（例如 vite-plugin-checker / vue-tsc / tsc -w 等）

#### 插件

Vite 的插件系统兼容/借鉴 Rollup 的插件接口，同时扩展了能影响 dev-server / SSR / runtime 的能力（即插件既能工作在 dev，也能工作在 build）

#### CSS / 静态资源（常见配置）

- 静态资源：默认会把较小文件（可以通过 build.assetsInlineLimit 调整）内联为 base64，其他资源会被哈希并输出到 dist。
- CSS 处理：Vite 默认用 PostCSS 流程，可配置 CSS modules、preprocessor（比如 scss）以及（较新版本）可选的 Lightning CSS 作为处理器/压缩器。

### webpack

#### webpack 设计哲学

一切资源皆模块（不仅是 JS，还包括 CSS、图片、字体…都可以通过 loader 转换为模块）。

#### 基本工作原理

webpack 的工作方式是： 从入口文件开始，分析依赖，然后递归地构建一个依赖图，最后根据依赖图生成一个打包后的文件。

源代码 → 入口分析 → 依赖图构建 → 模块转换 → 代码分割 → 输出文件

1. 初始化： 读取配置文件（webpack.config.js），合并默认配置。
2. 解析依赖图（Dependency Graph）：从入口文件（entry）开始，递归解析 import/require，构建模块依赖图。
3. Loader 转译：对不同类型资源用对应的 loader 进行转换（比如 .ts → .js，.scss → .css）。
4. 打包生成 Chunk：把模块打包成 Chunk（代码块），再进一步合并优化。
5. Plugin 扩展：在编译生命周期（compilation hooks）中由插件介入，做额外处理（压缩、环境变量注入、代码分割等）。
6. 输出：根据配置生成最终的打包文件（bundle），输出到指定目录。

#### 常见面试

Webpack 打包流程是怎样的？

- 从 entry 出发，构建依赖图 → Loader 转换 → Plugin 扩展 → 输出 bundle。

Loader 和 Plugin 区别？

- Loader：文件层面的转换器（把资源转成 JS 模块）。

- Plugin：整个编译流程的扩展器（基于生命周期 Hook）。

Tree Shaking 的原理？

- 利用 ES Module 的静态分析特性，删除未被引用的代码。

Webpack 为什么启动慢？

- 开发阶段必须先完整打包项目；相比之下 Vite 直接 ESM + 按需转换。

如何减小打包体积？

- Tree Shaking、SplitChunks、懒加载、压缩、图片优化。#

#### 常见的loader 和 plugins

1. babel-loader - JavaScript 转译核心

    作用： 将 ES6+/JSX/TypeScript 等现代 JavaScript 语法转换为浏览器兼容的 ES5 代码

    ES6+ 源码 → babel-loader → Babel Core → AST转换 → ES5代码

2. css-loader - CSS 模块化处理

    作用： 解析 CSS 文件中的 @import 和 url()，将 CSS 转换为 JS 模块

    ```js
    {
      test: /\.css$/,
      use: [
        'style-loader', // 将 CSS 注入到 DOM
        'css-loader'    // 解析 CSS 文件
      ]
    }```

3. postcss-loader - CSS 处理

作用： 处理 CSS 的兼容性问题（autoprefixer），支持 CSS 预处理器（如 SCSS）

CSS 源码 → postcss-loader → PostCSS 处理 → 兼容性 CSS

Plugins 详解

1. HtmlWebpackPlugin - HTML 文件生成

作用： 自动生成 HTML 文件，并自动注入打包后的资源文件

## Babel

Babel本质上是一个JavaScript编译器;主要作用是把新版本 JavaScript（ES6+、TS、JSX 等）转成向后兼容的代码（通常是 ES5），以保证在各种浏览器和运行环境下都能正常执行。

### 核心工作流程

#### 1. 解析过程

词法分析 → 语法分析 → AST生成

```js
// 输入代码
const arrow = () => {};

// 词法分析：分解为tokens
[
  { type: "Keyword", value: "const" },
  { type: "Identifier", value: "arrow" },
  { type: "Punctuator", value: "=" },
  // ...更多tokens
]

// 语法分析：构建AST
{
  type: "Program",
  body: [{
    type: "VariableDeclaration",
    declarations: [...]
  }]
}
```

#### 2. 转换过程

插件系统 → AST遍历 → 节点替换

Babel 使用各种 **插件（plugins）** 和 **预设（presets）**，遍历 AST，按规则修改语法树。

#### 3. 生成过程

AST → 代码字符串 → Source Map

将修改后的AST重新生成为JavaScript代码。

### babel总结

解析 → 转换 → 生成 三步走

Babel 本质是一个 源码到源码的编译器

强大之处在于 插件系统 和 生态（polyfill、TS、JSX 等支持）
