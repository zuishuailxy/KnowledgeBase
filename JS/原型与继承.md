# 原型链查找机制

## 原型

每个函数都有一个 prototype 属性，每个对象都有一个 `__proto__` 属性（指向其构造函数的 prototype）。

- 每个对象都有一个内部属性，指向另一个对象，这个被指向的对象就叫原型（prototype）。
- 当访问对象的属性或方法时，如果对象本身没有这个属性或方法，就会沿着原型链（prototype chain）向上查找，直到找到为止，或者到达原型链的尽头（即 Object.prototype，其原型为 null）。
- 通过原型，可以让多个对象共享同一组属性和方法，节省内存并实现继承。

```js
function Person(name) {
  this.name = name;
}
Person.prototype.sayHello = function() {
  console.log('Hello, ' + this.name);
};

const alice = new Person('Alice');
alice.sayHello(); // 输出：Hello, Alice

//alice 对象本身没有 sayHello 方法，但它的原型（Person.prototype）有，所以可以调用。
//这种机制就是“原型继承”。//
```

## 重要概念

`__proto__` : 所有对象都有的隐藏属性，指向其构造函数的 prototype
`prototype` : 函数特有的属性，用于构造函数创建实例时，作为实例的原型；

## 所有对象都继承自Object

```js
const obj = {};
console.log(obj.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

## 构造函数与原型关系

```js
function A() {}
const a = new A();

a.__proto__ === A.prototype; // ✅ true
A.prototype.constructor === A; // ✅ true
A.__proto__ === Function.prototype; // ✅ true  
```

## 原型链查找

JavaScript 会从当前对象本身开始查找属性，找不到就沿着它的 [[Prototype]]（即 __proto__）链条向上查找，直到 null 为止。

```js
function Person() {}
const alice = new Person();
console.log(alice.__proto__ === Person.prototype); // true
console.log(alice.__proto__.__proto__ === Object.prototype); // true
console.log(alice.__proto__.__proto__.__proto__ === null); // true
```

## class 语法糖

JS 中`class` 是一种 语法糖（syntactic sugar），本质上是对 原型继承机制 的一种更清晰、更面向对象的封装。

JavaScript 的 class 并不是引入了新的面向对象机制，而是对原有基于 构造函数+原型链 的封装，让语法更优雅、更接近传统语言（如 Java/C++）。

### 语法糖写法

```js
// class 写法
class Person {
  constructor(name) {
    this.name = name;         // 实例字段（如果用 class fields，则是每实例赋值）
  }
  say() {                     // 原型方法（不可枚举）
    console.log(`Hi, I'm ${this.name}`);
  }
  static create(name) {       // 静态方法（挂在构造器上）
    return new Person(name);
  }
}
```

### 构造函数实现继承

```js
// 近似等价的“构造函数 + 原型”写法
function Person(name) {
  this.name = name;
}
Object.defineProperty(Person.prototype, 'say', {
  value: function() { console.log(`Hi, I'm ${this.name}`); },
  enumerable: false, writable: true, configurable: true
});
Person.create = function(name) {
  return new Person(name);
};
```

### 继承

```js
// class 继承
class Student extends Person {
  constructor(name, grade) {
    super(name);       // 等价于 Person.call(this, name)
    this.grade = grade;
  }
  say() {
    super.say();       // 等价于 Person.prototype.say.call(this)
    console.log(`Grade: ${this.grade}`);
  }
  static of(name, grade) { return new Student(name, grade); }
}
```

```js
// 原型链实现
function Student(name, grade) {
  Person.call(this, name);
  this.grade = grade;
}
Student.prototype = Object.create(Person.prototype, {
  constructor: { value: Student, writable: true, configurable: true }
});
Object.setPrototypeOf
  ? Object.setPrototypeOf(Student, Person)
  : (Student.__proto__ = Person); // 继承静态方法
Student.prototype.say = function() {
  Person.prototype.say.call(this);
  console.log(`Grade: ${this.grade}`);
};
Student.of = function(name, grade) { return new Student(name, grade); };
```

### 特性总结

| 特性          | `class`                     | 构造函数 + 原型          |
| ----------- | --------------------------- | ------------------ |
| 定义方式        | 更简洁、面向对象风格                  | 稍显繁琐               |
| 方法定义位置      | 自动放在 `prototype` 上          | 需手动挂到 `prototype`  |
| 是否可以 hoist  | ❌ 不能提升（必须先定义）               | ✅ 函数可以提升           |
| 是否强制用 `new` | ✅ 必须使用 `new` 构造实例           | 构造函数建议用 `new`（不强制） |
| 私有属性支持      | ✅ ES2022 支持 `#privateField` | ❌ 传统构造函数不支持        |

### ES6 + class 的进阶语法特性

```js

class Person {
  static species = "Human"; // 静态属性

  #secret = "I'm private"; // 私有字段

  constructor(name) {
    this.name = name;
  }

  get displayName() {
    return `Name: ${this.name}`;
  }

  #whisper() {
    console.log(this.#secret);
  }

  revealSecret() {
    this.#whisper(); // 访问私有方法
  }
}
```

### 注意事项

1. 类不能直接调用，必须用 new 创建实例
2. `class`本质上还是函数（构造函数）：

   ```js
   typeof Person === 'function'; // true
    ```

3. 类不能像函数那样提升（hoisting）。
4. 类体中定义的方法默认是不可枚举的（这是与传统原型定义不同的点）。

### 结论

class 在 JS 中是对构造函数与原型模式的语法糖，带来默认不可枚举、严格模式、super、静态继承等语法层改进；语义依旧建立在原型链之上。

### 函数提升

在执行代码前，函数声明会被“提升”到当前作用域的顶部，因此你可以在函数定义之前调用它。

注意： 函数声明会被提升，但函数表达式不会。

#### 函数声明

```js
sayHello(); // ✅ 正常调用

function sayHello() {
  console.log("Hello");
}
//上面代码能运行，因为 sayHello 被提升到了顶部。
```

#### 函数表达式, 函数表达式不会被提升

```js
sayHello(); // ❌ TypeError: sayHello is not a function

var sayHello = function () {
  console.log("Hello");
};


sayHi(); // ❌ TypeError

var sayHi = () => {
  console.log("Hi");
};

```

## 组合继承 vs 原型继承

### 原型继承

最经典的“原型链继承”是让子类型的原型指向父类型实例：

```js
function Parent() {
  this.hobbies = ["code"];
}
Parent.prototype.say = function () {
  console.log("say from Parent");
};

function Child() {}

// 仅通过原型链继承
Child.prototype = new Parent();
Child.prototype.constructor = Child;

const c1 = new Child();
const c2 = new Child();
c1.hobbies.push("music");
console.log(c2.hobbies); // ["code", "music"] —— 引用类型被共享的坑
```

- __优点__：实现简单；方法共享在 `Parent.prototype` 上。
- __缺点__：
  - 父构造函数中的“引用类型属性”被所有子实例共享（互相污染）。
  - 无法给父构造函数“传参”（因为是 `new Parent()` 时固定了）。

原型链继承多用于只需共享方法、且父级无实例属性或仅有不可变属性的场景；在构造函数模式下并不实用。

### 组合继承（构造函数继承 + 原型链继承）

在子构造函数内部“借用构造函数”获取父类实例属性，再通过原型链继承父类方法：

```js
function Parent(name) {
  this.name = name;
  this.colors = ["red", "green"];
}
Parent.prototype.sayName = function () {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 1️⃣ 借用构造函数：拿到独立的实例属性，可传参
  this.age = age;
}

Child.prototype = new Parent(); // 2️⃣ 原型链继承：拿到父类原型方法
Child.prototype.constructor = Child;

const a = new Child("Alice", 18);
const b = new Child("Bob", 20);
a.colors.push("blue");
console.log(a.colors); // ["red", "green", "blue"]
console.log(b.colors); // ["red", "green"] —— 不再共享引用属性
a.sayName(); // Alice
```

- __优点__：
  - 解决了原型链继承无法传参、共享引用属性的问题。
  - 方法仍在原型上共享。
- __缺点（核心）__：父构造函数会被调用两次（一次 `Parent.call`，一次 `new Parent()`），导致子实例“遮蔽”了一份挂到原型上的父级实例属性，存在额外开销与冗余结构。

### 寄生组合继承（推荐）

在“组合继承”的基础上，避免“第二次调用父构造函数”。做法：用 `Object.create(Parent.prototype)` 建立原型链。

```js
function inherit(Sub, Super) {
  Sub.prototype = Object.create(Super.prototype, {
    constructor: { value: Sub, writable: true, configurable: true },
  });
  // 让 Sub 也继承 Super 的静态成员（可选，但与 class 行为一致）
  if (Object.setPrototypeOf) Object.setPrototypeOf(Sub, Super);
  else Sub.__proto__ = Super;
}

function Parent(name) {
  this.name = name;
  this.colors = ["red", "green"];
}
Parent.prototype.sayName = function () {
  console.log(this.name);
};

function Child(name, age) {
  Parent.call(this, name); // 只调用一次父构造函数
  this.age = age;
}

inherit(Child, Parent);

const x = new Child("X", 10);
const y = new Child("Y", 11);
x.colors.push("blue");
console.log(y.colors); // ["red", "green"]
x.sayName(); // X
```

- __优点__：保留组合继承的所有优点，并避免父构造函数二次调用；结构更干净、性能更好。
- __现代等价__：`class Child extends Parent { constructor(...) { super(...); } }` 的语义基本等同于“寄生组合继承”。

### 对比总结

- __原型继承（Child.prototype = new Parent()）__：
  - 简单，但会共享引用类型属性；不能给父构造器传参；实际项目不推荐单独使用。
- __组合继承（Parent.call + new Parent()）__：
  - 能传参、无共享引用属性；但父构造函数被调用两次，存在冗余。
- __寄生组合继承（Parent.call + Object.create）【推荐】__：
  - 只调用一次父构造函数，继承原型方法，避免共享引用属性；等价 `class extends` 行为，实践首选。
