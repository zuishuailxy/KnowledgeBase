# 作用域

变量和函数的可访问范围，决定了在哪些地方可以访问到变量

## 类型

### 全局作用域

- 定义: 在函数外或代码块外声明的变量，或者全局对象上定义的属性
- 特点：
  - 生命周期与页面一致，关闭时候销毁
  - 所有脚本和函数均可以访问，容易造成命名冲突和内存泄漏

### 函数作用域

- 定义: 在函数内部声明的变量（使用 var）,仅在该函数内部访问
- 特点：
  - 每次函数调用都会创建新的作用域，执行完毕后销毁
  - `var`声明的变量存在**变量提升**（声明提升到作用域顶部，初始化保留原位）

### 块级作用域

- 定义 由最近的`{}`包围的代码块形成的作用域，使用`let/const`声明的变量仅块内被访问
- 特点：
  - 无变量提升，存在暂时性死区，声明前访问会报错
  - 替代`var`，避免意外污染外部作用域

### 模块作用域

- 定义：ES6 模块中每个文件独立的作用域，需通过`export/import`共享变量
- 特点：
  - 默认隔离，避免全局污染
  - 支持按需加载和静态分析

## 核心机制

### 作用域链

- 定义：当 JS 引擎查找一个变量时，​**从当前作用域向外层作用域一层层查找，直到全局作用域为止**​。这形成了一个​**作用域链**​。由当前作用域及其所有外层作用域的变量对象组成

### 作用域链的形成

1. 创建阶段

   - 函数定义的时候，会创建一个包含其外部作用域的作用域链
   - 这个作用域链在函数创建时就确定了 （词法作用域）
2. 执行阶段

   - 函数被调用的时候，会创建一个新的执行上下文
   - 执行上下文包含一个变量对象（储存局部变量）

### 闭包

- 定义：函数在定义时“记住”了它创建时的作用域，即使这个函数在别的作用域中被调用，也能访问当初作用域里的变量。闭包本质上是函数连同它的词法作用域一起被保存在内存中。
- 特点：闭包可以访问其外部作用域的变量，即使外部函数已经执行完毕。变量依然被保留，没有被垃圾回收
- 应用：
  - 封装私有变量，实现模块化
  - 回调函数保留上下文

```TS
function createCounter() {
  let count = 0;  // 闭包保留的私有变量
  return () => count++;
}
const counter = createCounter();
counter() // 0
counter() // 1
```

### 闭包的实际应用

1. 数据私有化
把变量藏在函数作用域里，外部无法直接访问，只能通过暴露的方法访问：

```js
function createCounter() {
  let value = 0;
  return {
    inc: () => value++,
    get: () => value
  };
}

const counter = createCounter();
console.log(counter.get()); // 0
counter.inc();
console.log(counter.get()); // 1

```

2. 在回调中保存状态

```js
for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1000);
}
// 输出 0 1 2（let 创建了块级作用域，相当于闭包）
```

3. 函数工厂

```js
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```

4. 闭包的风险

- 内存泄漏：如果闭包引用了大对象，但长期不释放，就会占用内存。手动回收设置为null
- 滥用会导致调试困难：变量来源不明显，容易迷惑。

## 总结

理解作用域和作用域链是掌握 JavaScript 的关键：

1. ​**作用域**定义了变量和函数的可访问范围
2. ​**作用域链**决定了变量查找的顺序和规则
3. ​**闭包**是作用域链的重要应用，允许函数访问其词法作用域外的变量
4. ​**执行上下文**包含作用域链、变量对象和 this 值

### 垃圾回收机制

JS 中采用自动垃圾回收机制，来清理内存。

#### 可达性

在 JS 中，一个值如果从根对象（通常是 window 或 globalThis）通过引用链能被访问到，就被认为是“可达的”，不会被回收。

- 根对象： 全局变量、当前调用栈里的局部变量、闭包中的变量
- 如果某个值无法从根对象到达，就会被标记为“不可达”，进入回收流程。

#### 两种主要算法

1. 标记-清除（Mark-and-Sweep）

   - 通过根对象遍历所有可达对象，标记它们为“可达”
   - 然后清除所有未被标记的对象

    ```js
    // 垃圾回收过程示例
    let globalVar = { data: 'important' }; // 从全局可达，不会被回收

    function example() {
      let localVar = { temp: 'data' };     // 函数执行时可达
      
      return function() {
        return localVar.temp;              // 闭包引用，依然可达
      };
    }

    let closure = example();
    // localVar 通过闭包依然可达，不会被回收

    closure = null;
    // 现在 localVar 不可达了，会被回收
    ```

2. 引用计数（Reference Counting）- 会有循环引用问题

   - 统计每个对象被引用的次数
   - 当引用计数为零时，说明对象不再被使用，可以回收

    ```js
    let obj1 = { name: '张三' }; // obj1 引用计数: 1
    let obj2 = obj1;             // obj1 引用计数: 2
    obj2 = null;                 // obj1 引用计数: 1
    obj1 = null;                 // obj1 引用计数: 0，被回收
    ```

V8 主要使用 标记-清除 + 分代回收 + 增量 GC，而不是单纯引用计数。

#### 分代回收

- 定义：将对象分为新生代和老生代，分别采用不同的回收策略
- 特点：
  - 新生代：对象存活时间短，采用快速回收
  - 老生代：对象存活时间长，采用较慢的回收

```js
// 新生代对象示例
function createTempObjects() {
  for (let i = 0; i < 1000; i++) {
    let temp = { id: i, data: 'temp' }; // 很快会被回收
  }
}

// 老生代对象示例  
let persistentCache = new Map(); // 长期存在，移入老生代
```

#### 闭包为什么导致变量不被回收

闭包本质上是函数连同它的词法作用域一起被保存在内存中。
当一个内部函数在外部被引用时，即使外部函数已经执行结束，它的变量依然在作用域链中可达，所以不会被 GC。

```js
function createCounter() {
  let count = 0;                    // 这个变量会被闭包引用
  let unusedVar = 'not used';       // 这个可能会被优化掉
  
  return function() {
    return ++count;                 // count 通过闭包链依然可达
  };
}

let counter = createCounter();
// count 变量不会被回收，因为返回的函数依然引用它

counter = null;
// 现在 count 才会被回收
```

#### 闭包内存泄漏示例

```js
// 问题代码
function attachListeners() {
  let largeData = new Array(1000000).fill('data'); // 大数组
  
  document.getElementById('button').onclick = function() {
    console.log('clicked');
    // 即使不使用 largeData，它也不会被回收
    // 因为闭包会捕获整个作用域
  };
}

// 优化方案1：手动清除引用
function attachListenersFixed() {
  let largeData = new Array(1000000).fill('data');
  
  document.getElementById('button').onclick = function() {
    console.log('clicked');
  };
  
  largeData = null; // 手动清除引用
}

// 优化方案2：避免不必要的闭包
function attachListenersOptimal() {
  // 将处理函数分离，避免捕获不必要的变量
  document.getElementById('button').onclick = handleClick;
}

function handleClick() {
  console.log('clicked');
}
```

#### 常见的内存泄漏

1. 未清除的定时器

    ```js
    // 问题代码
    function startTimer() {
      let data = { large: 'object' };
      
      setInterval(() => {
        console.log(data.large); // data 永远不会被回收
      }, 1000);
    }

    // 解决方案
    function start`TimerFixed() {
      let data = { large: 'object' };
      
      let timerId = setInterval(() => {
        console.log(data.large);
      }, 1000);
      
      // 记得清除定时器
      setTimeout(() => {
        clearInterval(timerId);
        data = null;
      }, 10000);
    }
    ```

2. 未移除的事件监听器

    ```js
    // 问题代码
    function setupComponent() {
      let componentData = { /* 大量数据 */ };
      
      function handleResize() {
        // 使用 componentData
      }
      
      window.addEventListener('resize', handleResize);
      // 组件销毁时忘记移除监听器，造成内存泄漏
    }

    // 解决方案
    function setupComponentFixed() {
      let componentData = { /* 大量数据 */ };
      
      function handleResize() {
        // 使用 componentData
      }
      
      window.addEventListener('resize', handleResize);
      
      // 返回清理函数
      return function cleanup() {
        window.removeEventListener('resize', handleResize);
        componentData = null;
      };
    }
    ```

3. DOM 引用导致的泄漏

    ```js
    // 问题代码
    let elements = [];
    function addElements() {
      let div = document.createElement('div');
      document.body.appendChild(div);
      elements.push(div); // 即使从 DOM 移除，数组依然引用
    }

    function removeFromDOM() {
      document.body.removeChild(elements[0]); // 只从 DOM 移除
      // elements 数组依然持有引用，内存不会被回收
    }

    // 解决方案
    function removeElementProperly() {
      let element = elements.shift(); // 从数组移除
      if (element.parentNode) {
        element.parentNode.removeChild(element); // 从 DOM 移除
      }
      element = null; // 清除引用
    }
    ```
