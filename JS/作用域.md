# 作用域

变量和函数的可访问范围，决定了在哪些地方可以访问到变量

## 类型

### 全局作用域

- 定义: 在函数外或代码块外声明的变量，或者全局对象上定义的属性
- 特点：
  - 生命周期与页面一致，关闭时候销毁
  - 所有脚本和函数均可以访问，容易造成命名冲突和内存泄漏

### 函数作用域

- 定义: 在函数内部声明的变量（使用 var）,仅在该函数内部访问
- 特点：
  - 每次函数调用都会创建新的作用域，执行完毕后销毁
  - `var`声明的变量存在**变量提升**（声明提升到作用域顶部，初始化保留原位）

### 块级作用域

- 定义 由`{}`包围的代码块形成的作用域，使用`let/const`声明的变量仅快被访问
- 特点：
  - 无变量提升，存在暂时性死区，声明前访问会报错
  - 替代`var`，避免意外污染外部作用域

### 模块作用域

- 定义：ES6 模块中每个文件独立的作用域，需通过`export/import`共享变量
- 特点：
  - 默认隔离，避免全局污染
  - 支持按需加载和静态分析

## 核心机制

### 作用域链

- 定义：当 JS 引擎查找一个变量时，​**从当前作用域向外层作用域一层层查找，直到全局作用域为止**​。这形成了一个​**作用域链**​。由当前作用域及其所有外层作用域的变量对象组成

### 作用域链的形成

1. 创建阶段
   
   - 函数定义的时候，会创建一个包含其外部作用域的作用域链
   - 这个作用域链在函数创建时就确定了 （词法作用域）
2. 执行阶段
   
   - 函数被调用的时候，会创建一个新的执行上下文
   - 执行上下文包含一个变量对象（储存局部变量）

### 闭包

- 定义：函数保留其定义时的作用域链，即使外层函数已执行完毕
- 应用：
  - 封装私有变量，实现模块化
  - 回调函数保留上下文

```TS
function createCounter() {
  let count = 0;  // 闭包保留的私有变量
  return () => count++;
}
const counter = createCounter();
counter() // 0
counter() // 1
```

### 闭包的实际应用

1. 数据封装

```js
function createPerson(name) {
  let privateName = name;
  
  return {
    getName: () => privateName,
    setName: (newName) => { privateName = newName }
  };
}

const person = createPerson("张三");
console.log(person.getName()); // "张三"
person.setName("李四");
console.log(person.getName()); // "李四"
```

2. 事件处理

```js
function setupButtons() {
  const buttons = document.querySelectorAll('button');
  
  for (let i = 0; i < buttons.length; i++) {
    buttons[i].addEventListener('click', function() {
      console.log(`按钮 ${i} 被点击`);
    });
  }
}
```

3. 函数工厂

```js
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}

const double = createMultiplier(2);
const triple = createMultiplier(3);

console.log(double(5)); // 10
console.log(triple(5)); // 15
```






















