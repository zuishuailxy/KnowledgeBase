# 箭头函数

## 基本语法

```js
// 传统函数
function add(a, b) {
  return a + b;
}

// 箭头函数
const add = (a, b) => a + b;
```

## 语法变体

```js
// 1. 无参数
const sayHello = () => console.log("Hello!");

// 2. 单个参数（可省略括号）
const square = (x) => x * x;

// 3. 多个参数
const multiply = (a, b) => a * b;

// 4. 多行函数体（需要大括号和 return）
const divide = (a, b) => {
  if (b === 0) throw new Error("Cannot divide by zero");
  return a / b;
};

// 5. 返回对象（需要括号包裹）
const createUser = (name, age) => ({ name, age });
```

### 核心特性

1. **简洁的语法**

```js
// 传统回调
arr.map(function (item) {
  return item * 2;
});

// 箭头函数
arr.map((item) => item * 2);
```

2. **没有自己的 `this` 值： 箭头函数不绑定自己的 this，而是继承外层作用域的 this**

```js
const obj = {
  value: 42,
  getValue: function () {
    return this.value;
  },
};

const objArrow = {
  value: 42,
  getValue: () => {
    return this.value;
  },
};

console.log(obj.getValue()); // 42
console.log(objArrow.getValue()); // undefined（this 指向全局对象）
```

3. **没有自己的 `this` 值： 箭头函数不绑定自己的 this，而是继承外层作用域的 this**

```js
const showArgs = (...args) => {
  console.log(args); // 使用剩余参数替代
};

showArgs(1, 2, 3); // [1, 2, 3]
```

4. **不能作为构造函数**
   箭头函数不能使用`new`

```js
const Person = (name) => {
  this.name = name; // TypeError: Person is not a constructor
};

const bob = new Person("Bob");
```

5. **没有`prototype`属性**

```js
const arrow = () => {};
console.log(arrow.prototype); // undefined
```

### 与普通函数的对比

| **特性**           | **箭头函数**         | **普通函数**   |
| ------------------ | -------------------- | -------------- |
| **this 绑定**      | 词法作用域（静态）   | 动态绑定       |
| **arguments 对象** | 无                   | 有             |
| **构造函数 对象**  | 不可用               | 可用           |
| **prototype 属性** | 无                   | 有             |
| **generator 函数** |  不可用（无 yield）  | 可用           |
| **方法定义**       |  不适合（this 问题） | 适合           |
| **立即执行函数**   |  可用                | 可用           |
| **回调函数**       |  非常适合            | 可用需注意this |

### 最佳实践

1. **优先使用箭头函数**​：对于简单的函数表达式和回调函数
2. ​**避免在对象方法中使用**​：使用传统函数或方法简写
3. **注意 this 绑定**​：理解箭头函数中的 this 继承机制
4. **使用剩余参数代替 arguments**​：`(...args) => {}`
5. **保持简洁**​：单行箭头函数省略 return 和大括号
6. **命名复杂函数**​：对于复杂逻辑，使用命名函数提高可读性

