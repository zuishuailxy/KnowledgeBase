
# Vue 中的 diff 算法

## 为什么需要

- 在 Vue 中，视图更新依赖 虚拟 DOM。
- 当数据变化时，Vue 会生成新的虚拟 DOM 树，和旧的虚拟 DOM 树对比（diff），找到差异后再进行最小化的真实 DOM 操作。
- 这样避免了整个页面的重绘，提高性能。

## diff 核心原则

1. 同层比较,不跨层
    - Vue diff 算法只比较同一层级的节点，不会跨层级查找（复杂度从 O(n³) 降为 O(n)）。

2. 通过key 提高复用性
    - 如果子节点有 key，Vue 会用它来判断节点是否相同，避免重复销毁/创建。
    - key 很重要，可以避免列表渲染时出现意外的复用错误。

## diff 大致流程

假设我们有一组子节点，更新时进行 diff：

1. 头尾双指针对比

新旧子节点分别从 头和尾开始比较，如果相同则复用并继续。

2. key 对比 & 移动/新增/删除

如果节点不一样，Vue 会根据 key 进行查找：

找到相同 key → 复用并移动位置。

没找到 → 创建新节点。

3. 批量删除/新增

当一方的指针先到头，剩下的另一方就是需要新增或删除的节点。

## Vue3 的优化 （最长递增子序列 LIS）

Vue 3 在 核心 diff（children diff） 上做了优化：

- 找出新旧节点中可以保持顺序的最长子序列（LIS），这些节点可以直接复用，不需要移动。
- 只移动必要的节点，减少 DOM 操作。

👉 举个例子：
旧序列 [a, b, c, d]
新序列 [b, a, d, c]

Vue 2 可能会对 4 个节点都进行移动操作。

Vue 3 会找到最长递增子序列（例如 [b, d]），只需要移动 a 和 c，性能更高。

## 总结

Vue 2 diff：双端比较 + key 匹配 → 增删改最小化。

Vue 3 diff：在此基础上加了 最长递增子序列（LIS）优化 → 尽量减少移动操作。

Vue diff 主要逻辑：

双端指针：从新旧列表的头尾同时比较，快速处理相同的前缀和后缀。

中间乱序部分：通过 key 建立映射，找到可复用的节点。

最长递增子序列 (LIS)：在新序列中找到无需移动的节点，其余节点需要移动或新增。

这样既能 减少 DOM 操作次数，又能保证顺序正确。
