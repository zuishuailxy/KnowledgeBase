# 响应式原理

## vue2 的响应式原理（基于 Object.defineProperty）

- Vue 2 在初始化数据时，会用 Object.defineProperty 给对象的每个属性加上 getter / setter
- 当你访问 data.msg 时，触发 getter，把这个属性与当前正在渲染的 watcher 关联起来。
- 当你修改 data.msg 时，触发 setter，通知 watcher 更新。

缺点

- 不能检测到新加属性（要用 Vue.set）
- 不能检测到数组索引和 length 变化

## Vue 3 的响应式（基于 Proxy）

核心模块

### 1. 响应式对象 reactive()

- 用proxy 包装对象， 拦截get 和 set
- 访问时收集依赖 track, 修改时触发依赖 trigger

### 2. 依赖收集 track()

- Vue 内部有一个全局变量 activeEffect，指向当前正在运行的副作用函数（effect）。
- 在 get 时，把这个属性对应的依赖函数存进map

### 3. 派发更新 trigger()

- 在 set 时候找到依赖这个属性的副作用函数，重新执行

## 简化代码

```js
// 存放依赖关系：target -> key -> effects

const targetMap = new WeakMap()
let activeEffect = null

function reactive(target) {
  return new Proxy(target, {
    get(obj, key) {
      track(obj, key) 
      return Reflect.get(obj, key)
    }

    set (obj, key, val) {
      const res = Reflect.set(obj, key, val)
      trigger(obj, key)
      return res
    }
  })
}

function track(target, key) {
  if (!activeEffect) return;
  let depsMap = targetMap.get(target)
  if (!depsMap) targetMap.set(target, depsMap = new Map())
  let dep = depsMap.get(target)
  if(!dep) depsMap.set(key, dep = new Set())
  dep.add(activeEffect)
}

function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  const dep = depsMap.get(key);
  if (dep) dep.forEach(effect => effect());
}

function effect(fn) {
  activeEffect = fn;
  fn(); // 立即执行一次，收集依赖
  activeEffect = null;
}

```

## 衍生功能

### 1.ref()

- 本质是把单值用reactive 包装成 { value: xxx }。

### computed()

- 内部也是effect ,只不过它的返回值会缓存，只有依赖变化时才重新计算。

### watch()

- 就是手动注册一个 effect，当依赖变化时执行回调。

## 关键优势

性能更好：Proxy 只在访问/修改时劫持，不需要递归遍历所有属性。

功能更强：能监听新增/删除属性、数组索引、Map/Set 等。

更易扩展：通过 Reflect 保证原生操作行为一致。
