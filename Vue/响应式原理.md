# 响应式原理

## vue2 的响应式原理（基于 Object.defineProperty）

- Vue 2 在初始化数据时，会用 Object.defineProperty 给对象的每个属性加上 getter / setter
- 当你访问 data.msg 时，触发 getter，把这个属性与当前正在渲染的 watcher 关联起来。
- 当你修改 data.msg 时，触发 setter，通知 watcher 更新。

缺点

- 不能检测到新加属性（要用 Vue.set）
- 不能检测到数组索引和 length 变化

## Vue 3 的响应式（基于 Proxy）

核心模块

### 1. 响应式对象 reactive()

- 用proxy 包装对象， 拦截get 和 set
- 访问时收集依赖 track, 修改时触发依赖 trigger

### 2. 依赖收集 track()

- Vue 内部有一个全局变量 activeEffect，指向当前正在运行的副作用函数（effect）。
- 在 get 时，把这个属性对应的依赖函数存进map

### 3. 派发更新 trigger()

- 在 set 时候找到依赖这个属性的副作用函数，重新执行

## 简化代码

```js
// 存放依赖关系：target -> key -> effects

const targetMap = new WeakMap()
let activeEffect = null

function reactive(target) {
  return new Proxy(target, {
    get(obj, key) {
      track(obj, key) 
      return Reflect.get(obj, key)
    }

    set (obj, key, val) {
      const res = Reflect.set(obj, key, val)
      trigger(obj, key)
      return res
    }
  })
}

function track(target, key) {
  if (!activeEffect) return;
  let depsMap = targetMap.get(target)
  if (!depsMap) targetMap.set(target, depsMap = new Map())
  let dep = depsMap.get(target)
  if(!dep) depsMap.set(key, dep = new Set())
  dep.add(activeEffect)
}

function trigger(target, key) {
  const depsMap = targetMap.get(target);
  if (!depsMap) return;
  const dep = depsMap.get(key);
  if (dep) dep.forEach(effect => effect());
}

function effect(fn) {
  activeEffect = fn;
  fn(); // 立即执行一次，收集依赖
  activeEffect = null;
}

```

## 衍生功能

### 1.ref()

- 本质是把单值用reactive 包装成 { value: xxx }。

### computed()

- 内部也是effect ,只不过它的返回值会缓存，只有依赖变化时才重新计算。

### watch()

- 就是手动注册一个 effect，当依赖变化时执行回调。

## 关键优势

性能更好：Proxy 只在访问/修改时劫持，不需要递归遍历所有属性。

功能更强：能监听新增/删除属性、数组索引、Map/Set 等。

更易扩展：通过 Reflect 保证原生操作行为一致。

## 补充

### computed

#### 本质

- 基于依赖自动缓存的派生状态。

#### 特点

- 懒执行：只有当它被读取时，才会去计算。
- 缓存: 依赖未变化时,多次访问不会重新计算
- 依赖收集：当依赖的数据变化时，computed 会被标记为“脏”，下次访问才会重新计算。

#### 使用场景

- 基于已有数据派生新的值（显示逻辑、过滤、组合数据等）。
- 需要缓存的场景，比如计算开销大。

### watch

#### 本质

- 精确监听一个或多个响应式源，执行副作用函数

#### 特点

- 需要明确指定依赖源（ref、reactive、getter 函数、数组）
- 默认惰性：只有当依赖发生变化时，才会触发回调。
- 可以拿到新值 & 旧值。
- 可以配置 immediate: true 立即执行一次。

#### 使用场景

- 监听某个具体数据变化，做异步请求、副作用逻辑。
- 依赖变化时，执行额外操作（如本地存储更新）。


### watchEffect

#### 本质

- 自动收集依赖的响应式副作用。

#### 特点

- 不需要指定依赖，函数里用到的响应式数据都会被自动追踪。
- 创建时会立即执行一次，并且在依赖变化时重新运行
- 没有旧值参数（因为可能依赖多个源，难以确定旧值）。

#### 使用场景

- 快速响应依赖变化，不需要精确控制。
- 调试、简单副作用（比如 DOM 操作、打印日志）。
